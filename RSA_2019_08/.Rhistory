## based model -> no change in preferences!
klDivUttWorkers[workerIndex,2] <- 0
for(i in c(1:length(idICases))) {
len <- x3pilotData$numFeatures[idICases[i]]
for(j in c(1:len) ) {
klDivUttWorkers[workerIndex, 2] <- klDivUttWorkers[workerIndex, 2] +
sliderSetValues[idICases[i],j] *
(log(sliderSetValues[idICases[i],j] + 1e-100) - log(1/len))
if(is.na(klDivUttWorkers[workerIndex, 2])) {
print("Is NA!???")
print(c(sliderSetValues[idICases[i],j], log(1/len), i, j, len))
j <- 10
i <- length(idICases) +1
}
}
}
## done with this worker -> proceed
workerIndex <- workerIndex + 1
}
}
#######################
## Optimizing (i.e. minimzing) the KL Divergence values for each worker...
## starting with 1 parameter RSA model optimizations...
# data is a matrix with data rows. column structure: [1:OC1,OC2,OC3,4:numUttOptions,7-X(max 15):TurkerSliderValues]
workerIndex <- 1
for(workerID in c(0:idMax)) {
idICases <- which(workerIDs == workerID)
if(length(idICases)>0) {
## generating data matrix for the purpose of optimization
dataWorker <- matrix(0, length(idICases), 13)
dataWorker[,1] <- obj1OC27[idICases]
dataWorker[,2] <- obj2OC27[idICases]
dataWorker[,3] <- obj3OC27[idICases]
dataWorker[,4] <- x3pilotData$numFeatures[idICases]
dataWorker[,5:13] <- bInfGainUttTurkers[idICases,]
# print(dataWorker)
# now optimize for one parameter...
optRes1 <- optimize(SimpleRSAModelUttKLDivParamA, c(0,1e+10), dataWorker)
optRes2 <- optimize(SimpleRSAModelUttKLDivParamK.2.0, c(-10,10), dataWorker)
optRes3 <- optimize(SimpleRSAModelUttKLDivParamK, c(-10,10), dataWorker)
## 1 param RSA Utt model
klDivUttWorkers[workerIndex,3] <- optRes1$objective
klDivUttWorkers[workerIndex,4] <- optRes2$objective
klDivUttWorkers[workerIndex,5] <- optRes3$objective
## resulting parameter choice
paramsUttWorkers[workerIndex,2] <- optRes1$minimum
paramsUttWorkers[workerIndex,3] <- optRes2$minimum
paramsUttWorkers[workerIndex,4] <- optRes3$minimum
####
#    optRes2n1 <- optim(c(.2, .2), SimpleRSAModelUttKLDivParamBK, method="L-BFGS-B", gr=NULL, dataWorker,
#                       lower = c(0,-10), upper = c(1e+10,10))
optRes2n2 <- optim(c(.2, .2), SimpleRSAModelUttKLDivParamAK, method="L-BFGS-B", gr=NULL, dataWorker,
lower = c(0,-10), upper = c(1e+10,10))
#    optRes3 <- optim(c(.2, .2, 1), SimpleRSAModelUttKLDivParamABK, method="L-BFGS-B", gr=NULL, dataWorker,
#                     lower = c(0,0,-10), upper = c(1e+10,1e+10,10))
## 2 and 3 param RSA model2
## max likelihood parameter choice
#    klDivUttWorkers[workerIndex,6] <- optRes2n1$value
klDivUttWorkers[workerIndex,7] <- optRes2n2$value
#    klDivUttWorkers[workerIndex,8] <- optRes3$value
## max likelihood parameter choice
#    paramsUttWorkers[workerIndex,5] <- optRes2n1$par[1]
#    paramsUttWorkers[workerIndex,6] <- optRes2n1$par[2]
paramsUttWorkers[workerIndex,7] <- optRes2n2$par[1]
paramsUttWorkers[workerIndex,8] <- optRes2n2$par[2]
#    paramsUttWorkers[workerIndex,9] <- optRes3$par[1]
#    paramsUttWorkers[workerIndex,10] <- optRes3$par[2]
#    paramsUttWorkers[workerIndex,11] <- optRes3$par[3]
##
print(c("Done with worker ",workerIndex," with worder ID ", workerID))
print(c(klDivUttWorkers[workerIndex,], paramsUttWorkers[workerIndex,]))
####
workerIndex <- workerIndex + 1
}
}
write.csv(klDivUttWorkers, "X3_Data/x3KLDivs_simpleRSA_indOpt_2019_12_23.csv")
write.csv(paramsUttWorkers, "X3_Data/x3Params_simpleRSA_indOpt_2019_12_23.csv")
qchisq(.99,21)
qchisq(.999,21)
qchisq(.999,26)
qchisq(.999,8)
qchisq(.99,8)
qchisq(.99,33)
qchisq(.999,33)
qchisq(.9,17)
qchisq(.99,3)
qchisq(.992,3)
qchisq(.999,3)
qchisq(.999,82)
qchisq(.5,82)
qchisq(.1,82)
qchisq(.001,82)
qchisq(.01,82)
qchisq(.1,82)
qchisq(.999,33)
qchisq(.001,33)
qchisq(.999,33)
qchisq(.999,21)
source("CommonCode/getConstCodeStratUtt.R")
# loading the augmented pilot data (processed via RSA_x5UttChoiceDataProcessing01.R)
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_fixedAndD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_ADandBD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_ABandABD.csv")
x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_fixedAndD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_ADandBD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_ABandABD.csv")
## adding the 1-27 target and object2 & object3 code.
o1 <- x5UttChoiceData$obj1OC27
o2 <- x5UttChoiceData$obj2OC27
o3 <- x5UttChoiceData$obj3OC27
##
###########
## filtering for only the present feature values for each feature.
###########
subjectGuessIndexM1 <- grep("^DPost_1", colnames(x5UttChoiceData)) - 1
modelGuessIndex1M1 <- grep("^MPost1_1", colnames(x5UttChoiceData)) - 1
modelGuessIndex2M1 <- grep("^MPost2_1", colnames(x5UttChoiceData)) - 1
for(i in c(1:nrow(x5UttChoiceData))) {
currentObjects <- c(o1[i], o2[i], o3[i])
validUtterances <- determineValidUtterances(currentObjects)
for(j in c(1:3)) { # iterating over the three feature types
relevantIndices <- which(validUtterances>(3*(j-1)) & validUtterances<(3*j + 1)) # relevant indices for a particular feature type
valUttRel <- validUtterances[relevantIndices]
# setting the non-represented values to NA
for(v in c(1:3)) {
if(length(which(valUttRel == ((j-1)*3) + v )) == 0) {
x5UttChoiceData[[subjectGuessIndexM1 + ((j-1)*3) + v]][i] <- NA
x5UttChoiceData[[modelGuessIndex1M1 + ((j-1)*3) + v]][i] <- NA
x5UttChoiceData[[modelGuessIndex2M1 + ((j-1)*3) + v]][i] <- NA
}
}
}
}
## now determining the constellation code.
uniqueCCode <- rep(0, length(x5UttChoiceData$X))
featureOrder <- matrix(0, length(x5UttChoiceData$X), 3)
objectOrder <- matrix(0, length(x5UttChoiceData$X), 3)
featureValueOrder <- list()
for(i in c(1:length(x5UttChoiceData$X))) {
objectConstellation <- c(o1[i],o2[i],o3[i])
cc <- getUtteranceChoiceConstellationCode(objectConstellation)
uniqueCCode[i] <- cc[[1]]
featureOrder[i,] <- cc[[2]]
objectOrder[i,] <- cc[[3]]
featureValueOrder[[i]] <- cc[[4]]
}
# feature order specifies reordering of standard order (e.g. shape=1, texture=2, color=3)
# object order specifies reordering of presented object order
# featureValueOrder specifies how the present feature in an object constellation should be ordered.
subjectGuessIndex <- grep("^DPost_1", colnames(x5UttChoiceData))
modelGuessIndex1 <- grep("^MPost1_1", colnames(x5UttChoiceData))
modelGuessIndex2 <- grep("^MPost2_1", colnames(x5UttChoiceData))
x5UttChoiceData$CCode <- uniqueCCode
x5UttChoiceData$featValOrder <- featureValueOrder
#write.csv(x5UttChoiceData, "x5UttChoiceDataModelOptimizedSorted.csv")
################################################################################
x5UttChoiceData <- x5UttChoiceData[order(x5UttChoiceData$CCode),]
myCCodes <- unique(x5UttChoiceData$CCode)
avDataMatrix <- matrix(0,length(myCCodes),19)
dataPointIndex <- 0
workerData <- 0
rsaModel1 <- 0
rsaModel2 <- 0
runIndex <- 1
for(i in c(1:length(myCCodes))) {
cc <- myCCodes[i]
cases <- which(x5UttChoiceData$CCode == cc)
allPilotDataCases <- x5UttChoiceData[cases,]
workerMeans <- 0
rsaModel1Means <- 0
rsaModel2Means <- 0
for(j in c(1:nrow(allPilotDataCases))) {
workerMeans <-  workerMeans + allPilotDataCases[j,subjectGuessIndexM1+(allPilotDataCases$featValOrder[[j]])]
rsaModel1Means <- rsaModel1Means + allPilotDataCases[j,modelGuessIndex1M1+(allPilotDataCases$featValOrder[[j]])]
rsaModel2Means <- rsaModel2Means + allPilotDataCases[j,modelGuessIndex2M1+(allPilotDataCases$featValOrder[[j]])]
}
for(j in c(1:length(workerMeans))) {
workerData[runIndex] <- workerMeans[[j]] / nrow(allPilotDataCases)
rsaModel1[runIndex] <- rsaModel1Means[[j]] / nrow(allPilotDataCases)
rsaModel2[runIndex] <- rsaModel2Means[[j]] / nrow(allPilotDataCases)
runIndex <- runIndex+1
}
}
### plot after Optimization ###
rsaModel1 <- as.array(rsaModel1)
plot(rsaModel1, workerData)
abline(lm(formula = rsaModel1~workerData), col="red") # regression line (y~x)
lines(lowess(rsaModel1,workerData), col="blue") # lowess line (x,y)
model <- lm(formula = rsaModel1~workerData)
summary(model)
confint(model)
### plot with default parameters ###
plot(rsaModel2, workerData)
abline(lm(formula = rsaModel2~workerData), col="red") # regression line (y~x)
lines(lowess(rsaModel2,workerData), col="blue") # lowess line (x,y)
model <- lm(formula = rsaModel2~workerData)
summary(model)
confint(model)
source("CommonCode/getConstCodeStratUtt.R")
# loading the augmented pilot data (processed via RSA_x5UttChoiceDataProcessing01.R)
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_fixedAndD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_ADandBD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_ABandABD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_fixedAndD.csv")
x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_ADandBD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_ABandABD.csv")
## adding the 1-27 target and object2 & object3 code.
o1 <- x5UttChoiceData$obj1OC27
o2 <- x5UttChoiceData$obj2OC27
o3 <- x5UttChoiceData$obj3OC27
##
###########
## filtering for only the present feature values for each feature.
###########
subjectGuessIndexM1 <- grep("^DPost_1", colnames(x5UttChoiceData)) - 1
modelGuessIndex1M1 <- grep("^MPost1_1", colnames(x5UttChoiceData)) - 1
modelGuessIndex2M1 <- grep("^MPost2_1", colnames(x5UttChoiceData)) - 1
for(i in c(1:nrow(x5UttChoiceData))) {
currentObjects <- c(o1[i], o2[i], o3[i])
validUtterances <- determineValidUtterances(currentObjects)
for(j in c(1:3)) { # iterating over the three feature types
relevantIndices <- which(validUtterances>(3*(j-1)) & validUtterances<(3*j + 1)) # relevant indices for a particular feature type
valUttRel <- validUtterances[relevantIndices]
# setting the non-represented values to NA
for(v in c(1:3)) {
if(length(which(valUttRel == ((j-1)*3) + v )) == 0) {
x5UttChoiceData[[subjectGuessIndexM1 + ((j-1)*3) + v]][i] <- NA
x5UttChoiceData[[modelGuessIndex1M1 + ((j-1)*3) + v]][i] <- NA
x5UttChoiceData[[modelGuessIndex2M1 + ((j-1)*3) + v]][i] <- NA
}
}
}
}
## now determining the constellation code.
uniqueCCode <- rep(0, length(x5UttChoiceData$X))
featureOrder <- matrix(0, length(x5UttChoiceData$X), 3)
objectOrder <- matrix(0, length(x5UttChoiceData$X), 3)
featureValueOrder <- list()
for(i in c(1:length(x5UttChoiceData$X))) {
objectConstellation <- c(o1[i],o2[i],o3[i])
cc <- getUtteranceChoiceConstellationCode(objectConstellation)
uniqueCCode[i] <- cc[[1]]
featureOrder[i,] <- cc[[2]]
objectOrder[i,] <- cc[[3]]
featureValueOrder[[i]] <- cc[[4]]
}
# feature order specifies reordering of standard order (e.g. shape=1, texture=2, color=3)
# object order specifies reordering of presented object order
# featureValueOrder specifies how the present feature in an object constellation should be ordered.
subjectGuessIndex <- grep("^DPost_1", colnames(x5UttChoiceData))
modelGuessIndex1 <- grep("^MPost1_1", colnames(x5UttChoiceData))
modelGuessIndex2 <- grep("^MPost2_1", colnames(x5UttChoiceData))
x5UttChoiceData$CCode <- uniqueCCode
x5UttChoiceData$featValOrder <- featureValueOrder
#write.csv(x5UttChoiceData, "x5UttChoiceDataModelOptimizedSorted.csv")
################################################################################
x5UttChoiceData <- x5UttChoiceData[order(x5UttChoiceData$CCode),]
myCCodes <- unique(x5UttChoiceData$CCode)
avDataMatrix <- matrix(0,length(myCCodes),19)
dataPointIndex <- 0
workerData <- 0
rsaModel1 <- 0
rsaModel2 <- 0
runIndex <- 1
for(i in c(1:length(myCCodes))) {
cc <- myCCodes[i]
cases <- which(x5UttChoiceData$CCode == cc)
allPilotDataCases <- x5UttChoiceData[cases,]
workerMeans <- 0
rsaModel1Means <- 0
rsaModel2Means <- 0
for(j in c(1:nrow(allPilotDataCases))) {
workerMeans <-  workerMeans + allPilotDataCases[j,subjectGuessIndexM1+(allPilotDataCases$featValOrder[[j]])]
rsaModel1Means <- rsaModel1Means + allPilotDataCases[j,modelGuessIndex1M1+(allPilotDataCases$featValOrder[[j]])]
rsaModel2Means <- rsaModel2Means + allPilotDataCases[j,modelGuessIndex2M1+(allPilotDataCases$featValOrder[[j]])]
}
for(j in c(1:length(workerMeans))) {
workerData[runIndex] <- workerMeans[[j]] / nrow(allPilotDataCases)
rsaModel1[runIndex] <- rsaModel1Means[[j]] / nrow(allPilotDataCases)
rsaModel2[runIndex] <- rsaModel2Means[[j]] / nrow(allPilotDataCases)
runIndex <- runIndex+1
}
}
### plot after Optimization ###
rsaModel1 <- as.array(rsaModel1)
plot(rsaModel1, workerData)
abline(lm(formula = rsaModel1~workerData), col="red") # regression line (y~x)
lines(lowess(rsaModel1,workerData), col="blue") # lowess line (x,y)
model <- lm(formula = rsaModel1~workerData)
summary(model)
confint(model)
### plot with default parameters ###
plot(rsaModel2, workerData)
abline(lm(formula = rsaModel2~workerData), col="red") # regression line (y~x)
lines(lowess(rsaModel2,workerData), col="blue") # lowess line (x,y)
model <- lm(formula = rsaModel2~workerData)
summary(model)
confint(model)
source("CommonCode/getConstCodeStratUtt.R")
# loading the augmented pilot data (processed via RSA_x5UttChoiceDataProcessing01.R)
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_fixedAndD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_ADandBD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_ABandABD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_fixedAndD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_ADandBD.csv")
x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_ABandABD.csv")
## adding the 1-27 target and object2 & object3 code.
o1 <- x5UttChoiceData$obj1OC27
o2 <- x5UttChoiceData$obj2OC27
o3 <- x5UttChoiceData$obj3OC27
##
###########
## filtering for only the present feature values for each feature.
###########
subjectGuessIndexM1 <- grep("^DPost_1", colnames(x5UttChoiceData)) - 1
modelGuessIndex1M1 <- grep("^MPost1_1", colnames(x5UttChoiceData)) - 1
modelGuessIndex2M1 <- grep("^MPost2_1", colnames(x5UttChoiceData)) - 1
for(i in c(1:nrow(x5UttChoiceData))) {
currentObjects <- c(o1[i], o2[i], o3[i])
validUtterances <- determineValidUtterances(currentObjects)
for(j in c(1:3)) { # iterating over the three feature types
relevantIndices <- which(validUtterances>(3*(j-1)) & validUtterances<(3*j + 1)) # relevant indices for a particular feature type
valUttRel <- validUtterances[relevantIndices]
# setting the non-represented values to NA
for(v in c(1:3)) {
if(length(which(valUttRel == ((j-1)*3) + v )) == 0) {
x5UttChoiceData[[subjectGuessIndexM1 + ((j-1)*3) + v]][i] <- NA
x5UttChoiceData[[modelGuessIndex1M1 + ((j-1)*3) + v]][i] <- NA
x5UttChoiceData[[modelGuessIndex2M1 + ((j-1)*3) + v]][i] <- NA
}
}
}
}
## now determining the constellation code.
uniqueCCode <- rep(0, length(x5UttChoiceData$X))
featureOrder <- matrix(0, length(x5UttChoiceData$X), 3)
objectOrder <- matrix(0, length(x5UttChoiceData$X), 3)
featureValueOrder <- list()
for(i in c(1:length(x5UttChoiceData$X))) {
objectConstellation <- c(o1[i],o2[i],o3[i])
cc <- getUtteranceChoiceConstellationCode(objectConstellation)
uniqueCCode[i] <- cc[[1]]
featureOrder[i,] <- cc[[2]]
objectOrder[i,] <- cc[[3]]
featureValueOrder[[i]] <- cc[[4]]
}
# feature order specifies reordering of standard order (e.g. shape=1, texture=2, color=3)
# object order specifies reordering of presented object order
# featureValueOrder specifies how the present feature in an object constellation should be ordered.
subjectGuessIndex <- grep("^DPost_1", colnames(x5UttChoiceData))
modelGuessIndex1 <- grep("^MPost1_1", colnames(x5UttChoiceData))
modelGuessIndex2 <- grep("^MPost2_1", colnames(x5UttChoiceData))
x5UttChoiceData$CCode <- uniqueCCode
x5UttChoiceData$featValOrder <- featureValueOrder
#write.csv(x5UttChoiceData, "x5UttChoiceDataModelOptimizedSorted.csv")
################################################################################
x5UttChoiceData <- x5UttChoiceData[order(x5UttChoiceData$CCode),]
myCCodes <- unique(x5UttChoiceData$CCode)
avDataMatrix <- matrix(0,length(myCCodes),19)
dataPointIndex <- 0
workerData <- 0
rsaModel1 <- 0
rsaModel2 <- 0
runIndex <- 1
for(i in c(1:length(myCCodes))) {
cc <- myCCodes[i]
cases <- which(x5UttChoiceData$CCode == cc)
allPilotDataCases <- x5UttChoiceData[cases,]
workerMeans <- 0
rsaModel1Means <- 0
rsaModel2Means <- 0
for(j in c(1:nrow(allPilotDataCases))) {
workerMeans <-  workerMeans + allPilotDataCases[j,subjectGuessIndexM1+(allPilotDataCases$featValOrder[[j]])]
rsaModel1Means <- rsaModel1Means + allPilotDataCases[j,modelGuessIndex1M1+(allPilotDataCases$featValOrder[[j]])]
rsaModel2Means <- rsaModel2Means + allPilotDataCases[j,modelGuessIndex2M1+(allPilotDataCases$featValOrder[[j]])]
}
for(j in c(1:length(workerMeans))) {
workerData[runIndex] <- workerMeans[[j]] / nrow(allPilotDataCases)
rsaModel1[runIndex] <- rsaModel1Means[[j]] / nrow(allPilotDataCases)
rsaModel2[runIndex] <- rsaModel2Means[[j]] / nrow(allPilotDataCases)
runIndex <- runIndex+1
}
}
### plot after Optimization ###
rsaModel1 <- as.array(rsaModel1)
plot(rsaModel1, workerData)
abline(lm(formula = rsaModel1~workerData), col="red") # regression line (y~x)
lines(lowess(rsaModel1,workerData), col="blue") # lowess line (x,y)
model <- lm(formula = rsaModel1~workerData)
summary(model)
confint(model)
### plot with default parameters ###
plot(rsaModel2, workerData)
abline(lm(formula = rsaModel2~workerData), col="red") # regression line (y~x)
lines(lowess(rsaModel2,workerData), col="blue") # lowess line (x,y)
model <- lm(formula = rsaModel2~workerData)
summary(model)
confint(model)
source("CommonCode/getConstCodeStratUtt.R")
# loading the augmented pilot data (processed via RSA_x6PilotDataProcessing01.R)
#x6pilotData <- read.csv("X6_Data/x6pilotDataAugm_UttChoice_RSA_fixedAndD_2019_05_29.csv")
#x6pilotData <- read.csv("X6_Data/x6pilotDataAugm_UttChoice_RSA_ADandBD_052019.csv")
#x6pilotData <- read.csv("X6_Data/x6pilotDataAugm_UttChoice_RSA_ABandABD_052019.csv")
x6pilotData <- read.csv("X6_Data/x6pilotDataAugm_UttChoice_SRSA_fixedAndD_2019_05_29.csv")
#x6pilotData <- read.csv("X6_Data/x6pilotDataAugm_UttChoice_SRSA_ADandBD_052019.csv")
#x6pilotData <- read.csv("X6_Data/x6pilotDataAugm_UttChoice_SRSA_ABandABD_052019.csv")
## adding the 1-27 target and object2 & object3 code.
o1 <- x6pilotData$obj1OC27
o2 <- x6pilotData$obj2OC27
o3 <- x6pilotData$obj3OC27
##
###########
## filtering for only the present feature values for each feature.
###########
subjectGuessIndexM1 <- grep("^DPost_1", colnames(x6pilotData)) - 1
modelGuessIndex1M1 <- grep("^MPost1_1", colnames(x6pilotData)) - 1
modelGuessIndex2M1 <- grep("^MPost2_1", colnames(x6pilotData)) - 1
for(i in c(1:nrow(x6pilotData))) {
currentObjects <- c(o1[i], o2[i], o3[i])
validUtterances <- determineValidUtterances(currentObjects)
for(j in c(1:3)) { # iterating over the three feature types
relevantIndices <- which(validUtterances>(3*(j-1)) & validUtterances<(3*j + 1)) # relevant indices for a particular feature type
valUttRel <- validUtterances[relevantIndices]
# setting the non-represented values to NA
for(v in c(1:3)) {
if(length(which(valUttRel == ((j-1)*3) + v )) == 0) {
x6pilotData[[subjectGuessIndexM1 + ((j-1)*3) + v]][i] <- NA
x6pilotData[[modelGuessIndex1M1 + ((j-1)*3) + v]][i] <- NA
x6pilotData[[modelGuessIndex2M1 + ((j-1)*3) + v]][i] <- NA
}
}
}
}
## now determining the constellation code.
uniqueCCode <- rep(0, length(x6pilotData$X))
featureOrder <- matrix(0, length(x6pilotData$X), 3)
objectOrder <- matrix(0, length(x6pilotData$X), 3)
featureValueOrder <- list()
for(i in c(1:length(x6pilotData$X))) {
objectConstellation <- c(o1[i],o2[i],o3[i])
cc <- getUtteranceChoiceConstellationCode(objectConstellation)
uniqueCCode[i] <- cc[[1]]
featureOrder[i,] <- cc[[2]]
objectOrder[i,] <- cc[[3]]
featureValueOrder[[i]] <- cc[[4]]
}
# feature order specifies reordering of standard order (e.g. shape=1, texture=2, color=3)
# object order specifies reordering of presented object order
# featureValueOrder specifies how the present feature in an object constellation should be ordered.
subjectGuessIndex <- grep("^DPost_1", colnames(x6pilotData))
modelGuessIndex1 <- grep("^MPost1_1", colnames(x6pilotData))
modelGuessIndex2 <- grep("^MPost2_1", colnames(x6pilotData))
x6pilotData$CCode <- uniqueCCode
x6pilotData$featValOrder <- featureValueOrder
modelDataOrdered <- matrix(-1,nrow(x6pilotData),16)
for(i in c(1:length(x6pilotData$X))) {
for(j in c(1:length(x6pilotData$featValOrder[[i]]))) {
modelDataOrdered[i,j] <- x6pilotData[[modelGuessIndex2M1+x6pilotData$featValOrder[[i]][j]]][i]
}
}
modelDataOrdered[,10] <- uniqueCCode
modelDataOrdered[,11] <- x6pilotData$obj1
modelDataOrdered[,12] <- x6pilotData$obj2
modelDataOrdered[,13] <- x6pilotData$obj3
modelDataOrdered[,14] <- x6pilotData$obj1OC27
modelDataOrdered[,15] <- x6pilotData$obj2OC27
modelDataOrdered[,16] <- x6pilotData$obj3OC27
write.csv(modelDataOrdered, "x6pilotDataModelOptimizedSorted.csv")
################################################################################
x6pilotData <- x6pilotData[order(x6pilotData$CCode),]
myCCodes <- unique(x6pilotData$CCode)
avDataMatrix <- matrix(0,length(myCCodes),19)
dataPointIndex <- 0
workerData <- 0
rsaModel1 <- 0
rsaModel2 <- 0
runIndex <- 1
for(i in c(1:length(myCCodes))) {
cc <- myCCodes[i]
cases <- which(x6pilotData$CCode == cc)
allPilotDataCases <- x6pilotData[cases,]
workerMeans <- 0
rsaModel1Means <- 0
rsaModel2Means <- 0
for(j in c(1:nrow(allPilotDataCases))) {
workerMeans <-  workerMeans + allPilotDataCases[j,subjectGuessIndexM1+(allPilotDataCases$featValOrder[[j]])]
rsaModel1Means <- rsaModel1Means + allPilotDataCases[j,modelGuessIndex1M1+(allPilotDataCases$featValOrder[[j]])]
rsaModel2Means <- rsaModel2Means + allPilotDataCases[j,modelGuessIndex2M1+(allPilotDataCases$featValOrder[[j]])]
}
for(j in c(1:length(workerMeans))) {
workerData[runIndex] <- workerMeans[[j]] / nrow(allPilotDataCases)
rsaModel1[runIndex] <- rsaModel1Means[[j]] / nrow(allPilotDataCases)
rsaModel2[runIndex] <- rsaModel2Means[[j]] / nrow(allPilotDataCases)
runIndex <- runIndex+1
}
}
### plot after Optimization ###
rsaModel1 <- as.array(rsaModel1)
plot(rsaModel1, workerData)
abline(lm(formula = rsaModel1~workerData), col="red") # regression line (y~x)
lines(lowess(rsaModel1,workerData), col="blue") # lowess line (x,y)
model <- lm(formula = rsaModel1~workerData)
summary(model)
confint(model)
### plot with default parameters ###
rsaModel2 <- as.array(rsaModel2)
plot(rsaModel2, workerData)
abline(lm(formula = rsaModel2~workerData), col="red") # regression line (y~x)
lines(lowess(rsaModel2,workerData), col="blue") # lowess line (x,y)
model <- lm(formula = rsaModel2~workerData)
summary(model)
confint(model)
