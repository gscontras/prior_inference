colIndex <- sliderIndex + (i-1) * 2
relRows <- which(!is.na(x5pilotData[[colIndex]]))
for(j in c(1:length(relRows) ) ) {
sliderUtteranceTypes[relRows[j], i] <- which(allUtterancesNew1==x5pilotData[[colIndex]][relRows[j]])
sliderSetValues[relRows[j], i] <- x5pilotData[[colIndex+1]][relRows[j]]
}
}
### normalizing the turker estimates and setting them into the corresponding matrix.
bInfGainUttTurkers <- matrix(NA, nrow(x5pilotData), 9)
for(i in c(1:nrow(x5pilotData)) ) {
s <- sum(sliderSetValues[i,c(1:x5pilotData$numFeatures[i])])
if(s > 0) {
sliderSetValues[i,c(1:x5pilotData$numFeatures[i])] <- sliderSetValues[i,c(1:x5pilotData$numFeatures[i])] / s
}else{
sliderSetValues[i,c(1:x5pilotData$numFeatures[i])] <- 1 / (x5pilotData$numFeatures[i])
}
bInfGainUttTurkers[i, sliderUtteranceTypes[i,c(1:(x5pilotData$numFeatures[i]) )] ] <- sliderSetValues[i,c(1:(x5pilotData$numFeatures[i]) )]
for(j in c(1:x5pilotData$numFeatures[i])) {
if(is.na(sliderSetValues[i,j])) {
print("ERRor")
}
}
}
#pragmaticSpeaker <- function(utterance, obj, preferencesPrior,
#                             relevantUtterances, currentObjects, mapUttToObjProbs,
#                             objectPreferenceSoftPriors, alpha) {
#bestInfGainUtterance <- function(preferencesPrior, relevantUtterances, currentObjects,
#                                 mapUttToObjProbs, objectPreferenceSoftPriors, alpha) {
## reloading optimization values
#paramsUttWorkers <- as.matrix(read.csv("X5_Data/KLDivUttParamsWorkers_x5_UttChoiceSimpleRSA_2019_06_03.csv"))
#paramsUttWorkers <- paramsUttWorkers[ , 2:ncol(paramsUttWorkers)]
paramsUttWorkers <- as.matrix(read.csv("X5_Data/KLDivUttParamsWorkers_x5_UttChoiceSimpleRSA.2_2019_06_03.csv"))
paramsUttWorkers <- paramsUttWorkers[ , 2:ncol(paramsUttWorkers)]
#klDivUttWorkers <- as.matrix(read.csv("X5_Data/KLDivUttWorkersWith.2_x6_2019_05_16.csv"))
#klDivUttWorkers <- klDivUttWorkers[ , 2:ncol(klDivUttWorkers)]
#paramsUttWorkers <- as.matrix(read.csv("X5_Data/KLDivUttParamsWorkersWith.2_x6_2019_05_16.csv"))
#paramsUttWorkers <- paramsUttWorkers[ , 2:ncol(paramsUttWorkers)]
#####################################################################################################
##############  TIME To determine and record the actual (optimized) Model Predictions ###############
#####################################################################################################
###
# determining the model predictions after worker-specific model parameter optimization!
postListMat <- matrix(0,length(x5pilotData$X),9)
postListMat2 <- matrix(0,length(x5pilotData$X),9)
klDivValues <- matrix(NA,length(x5pilotData$X),3)
workerID <- -1
for(i in c(1:length(x5pilotData$X))) {
objectConstellation <- c(obj1OC27[i],obj2OC27[i],obj3OC27[i])
if(workerID != x5pilotData$workerid[i]) {
workerID <- x5pilotData$workerid[i]
params <- paramsUttWorkers[which(paramsUttWorkers[,1]==workerID)[1],c(4:4)]
paramsAD <- paramsUttWorkers[which(paramsUttWorkers[,1]==workerID)[1],c(7:8)]
paramsBD <- paramsUttWorkers[which(paramsUttWorkers[,1]==workerID)[1],c(5:6)]
paramsAB <- paramsUttWorkers[which(paramsUttWorkers[,1]==workerID)[1],c(9:10)]
paramsABD <- paramsUttWorkers[which(paramsUttWorkers[,1]==workerID)[1],c(11:13)]
# print(params)
}
##
validUtterances <- determineValidUtterances(objectConstellation)
## determining the model predictions
#  postListMat[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, 0, 0, 1)
#  postListMat2[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, 0, 0, params[1])
#  postListMat[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, paramsAD[1], 0, paramsAD[2])
#  postListMat2[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, 0, paramsBD[1], paramsBD[2])
#   postListMat[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, paramsAB[1], paramsAB[2], 1)
#   postListMat2[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, paramsABD[1], paramsABD[2], paramsABD[3])
########### with respect to KLDivUttParamsWorkersWith.2_x6_2019_05_16.csv
postListMat[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, 0.2, 0.2, 1)
postListMat2[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, 0.2, 0.2, params[1])
#  postListMat[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, paramsAD[1], 0.2, paramsAD[2])
#  postListMat2[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, 0.2, paramsBD[1], paramsBD[2])
}
###########
## adding all those values to the x4pilotData table.
subjectResponses <- round(bInfGainUttTurkers, digits=3)
colnames(subjectResponses) <- colnames(subjectResponses, do.NULL = FALSE, prefix = "DPost_")
x5pilotData <- data.frame(x5pilotData, as.data.frame(subjectResponses))
postListMat <- round(postListMat, digits=3)
colnames(postListMat) <- colnames(postListMat, do.NULL = FALSE, prefix = "MPost1_")
x5pilotData <- data.frame(x5pilotData, as.data.frame(postListMat))
postListMat2 <- round(postListMat2, digits=3)
colnames(postListMat2) <- colnames(postListMat2, do.NULL = FALSE, prefix = "MPost2_")
x5pilotData <- data.frame(x5pilotData, as.data.frame(postListMat2))
klDivValues <- round(klDivValues, digits=3)
colnames(klDivValues) <- colnames(klDivValues, do.NULL = FALSE, prefix = "KLDiv_")
x5pilotData <- data.frame(x5pilotData, as.data.frame(klDivValues))
#write.csv(x5pilotData, "X5_Data/x5pilotDataAugm_UttChoice_SRSA_fixedAndD.csv")
#write.csv(x5pilotData, "X5_Data/x5pilotDataAugm_UttChoice_SRSA_ADandBD.csv")
#write.csv(x5pilotData, "X5_Data/x5pilotDataAugm_UttChoice_SRSA_ABandABD.csv")
write.csv(x5pilotData, "X5_Data/x5pilotDataAugm_UttChoice_SRSA.2_fixedAndD.csv")
#write.csv(x5pilotData, "X5_Data/x5pilotDataAugm_UttChoice_SRSA_ABandABD.csv")
source("CommonCode/SRSA_StratUtt.R")
source("CommonCode/SRSA_UttChoiceOptimization.R")
# loading the raw pilot data (as Greg sent it on 2018/12/21)
x5pilotData <- read.csv("X5_Data/5-combined-unique.csv")
x5pilotData <- x5pilotData[which(x5pilotData$trial_type=="utterance_choice"),]
## adding the 1-27 target and object2 & object3 code.
temp <- x5pilotData$obj1
temp2 <- (temp - temp %% 10) / 10
temp3 <- (temp2 - temp2 %% 10) / 10
obj1OC27 <- temp3 + 3 * ((temp2 %% 10) - 1) + 9 * ((temp %% 10) - 1)
x5pilotData$obj1OC27 <- obj1OC27
temp <- x5pilotData$obj2
temp2 <- (temp - temp %% 10) / 10
temp3 <- (temp2 - temp2 %% 10) / 10
obj2OC27 <- temp3 + 3 * ((temp2 %% 10) - 1) + 9 * ((temp %% 10) - 1)
x5pilotData$obj2OC27 <- obj2OC27
temp <- x5pilotData$obj3
temp2 <- (temp - temp %% 10) / 10
temp3 <- (temp2 - temp2 %% 10) / 10
obj3OC27 <- temp3 + 3 * ((temp2 %% 10) - 1) + 9 * ((temp %% 10) - 1)
x5pilotData$obj3OC27 <- obj3OC27
## now identify the first column number of the turker sliders and response pairs
sliderIndex <- grep("^pref1", colnames(x5pilotData))
## and use that index to determine all slider identities and corresponding slider values.
sliderUtteranceTypes <- matrix(NA, nrow(x5pilotData), 9)
sliderSetValues <- matrix(NA,  nrow(x5pilotData), 9)
for(i in c(1:9)) {
colIndex <- sliderIndex + (i-1) * 2
relRows <- which(!is.na(x5pilotData[[colIndex]]))
for(j in c(1:length(relRows) ) ) {
sliderUtteranceTypes[relRows[j], i] <- which(allUtterancesNew1==x5pilotData[[colIndex]][relRows[j]])
sliderSetValues[relRows[j], i] <- x5pilotData[[colIndex+1]][relRows[j]]
}
}
### normalizing the turker estimates and setting them into the corresponding matrix.
bInfGainUttTurkers <- matrix(NA, nrow(x5pilotData), 9)
for(i in c(1:nrow(x5pilotData)) ) {
s <- sum(sliderSetValues[i,c(1:x5pilotData$numFeatures[i])])
if(s > 0) {
sliderSetValues[i,c(1:x5pilotData$numFeatures[i])] <- sliderSetValues[i,c(1:x5pilotData$numFeatures[i])] / s
}else{
sliderSetValues[i,c(1:x5pilotData$numFeatures[i])] <- 1 / (x5pilotData$numFeatures[i])
}
bInfGainUttTurkers[i, sliderUtteranceTypes[i,c(1:(x5pilotData$numFeatures[i]) )] ] <- sliderSetValues[i,c(1:(x5pilotData$numFeatures[i]) )]
for(j in c(1:x5pilotData$numFeatures[i])) {
if(is.na(sliderSetValues[i,j])) {
print("ERRor")
}
}
}
#pragmaticSpeaker <- function(utterance, obj, preferencesPrior,
#                             relevantUtterances, currentObjects, mapUttToObjProbs,
#                             objectPreferenceSoftPriors, alpha) {
#bestInfGainUtterance <- function(preferencesPrior, relevantUtterances, currentObjects,
#                                 mapUttToObjProbs, objectPreferenceSoftPriors, alpha) {
## reloading optimization values
#paramsUttWorkers <- as.matrix(read.csv("X5_Data/KLDivUttParamsWorkers_x5_UttChoiceSimpleRSA_2019_06_03.csv"))
#paramsUttWorkers <- paramsUttWorkers[ , 2:ncol(paramsUttWorkers)]
paramsUttWorkers <- as.matrix(read.csv("X5_Data/KLDivUttParamsWorkers_x5_UttChoiceSimpleRSA.2_2019_06_03.csv"))
paramsUttWorkers <- paramsUttWorkers[ , 2:ncol(paramsUttWorkers)]
#klDivUttWorkers <- as.matrix(read.csv("X5_Data/KLDivUttWorkersWith.2_x6_2019_05_16.csv"))
#klDivUttWorkers <- klDivUttWorkers[ , 2:ncol(klDivUttWorkers)]
#paramsUttWorkers <- as.matrix(read.csv("X5_Data/KLDivUttParamsWorkersWith.2_x6_2019_05_16.csv"))
#paramsUttWorkers <- paramsUttWorkers[ , 2:ncol(paramsUttWorkers)]
#####################################################################################################
##############  TIME To determine and record the actual (optimized) Model Predictions ###############
#####################################################################################################
###
# determining the model predictions after worker-specific model parameter optimization!
postListMat <- matrix(0,length(x5pilotData$X),9)
postListMat2 <- matrix(0,length(x5pilotData$X),9)
klDivValues <- matrix(NA,length(x5pilotData$X),3)
workerID <- -1
for(i in c(1:length(x5pilotData$X))) {
objectConstellation <- c(obj1OC27[i],obj2OC27[i],obj3OC27[i])
if(workerID != x5pilotData$workerid[i]) {
workerID <- x5pilotData$workerid[i]
params <- paramsUttWorkers[which(paramsUttWorkers[,1]==workerID)[1],c(4:4)]
paramsAD <- paramsUttWorkers[which(paramsUttWorkers[,1]==workerID)[1],c(7:8)]
paramsBD <- paramsUttWorkers[which(paramsUttWorkers[,1]==workerID)[1],c(5:6)]
paramsAB <- paramsUttWorkers[which(paramsUttWorkers[,1]==workerID)[1],c(9:10)]
paramsABD <- paramsUttWorkers[which(paramsUttWorkers[,1]==workerID)[1],c(11:13)]
# print(params)
}
##
validUtterances <- determineValidUtterances(objectConstellation)
## determining the model predictions
#  postListMat[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, 0, 0, 1)
#  postListMat2[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, 0, 0, params[1])
#  postListMat[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, paramsAD[1], 0, paramsAD[2])
#  postListMat2[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, 0, paramsBD[1], paramsBD[2])
#   postListMat[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, paramsAB[1], paramsAB[2], 1)
#   postListMat2[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, paramsABD[1], paramsABD[2], paramsABD[3])
########### with respect to KLDivUttParamsWorkersWith.2_x6_2019_05_16.csv
#  postListMat[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, 0.2, 0.2, 1)
#  postListMat2[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, 0.2, 0.2, params[1])
postListMat[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, paramsAD[1], 0.2, paramsAD[2])
postListMat2[i,validUtterances] <- getSimpleBestInfGainUttPreferences(objectConstellation, 0.2, paramsBD[1], paramsBD[2])
}
###########
## adding all those values to the x4pilotData table.
subjectResponses <- round(bInfGainUttTurkers, digits=3)
colnames(subjectResponses) <- colnames(subjectResponses, do.NULL = FALSE, prefix = "DPost_")
x5pilotData <- data.frame(x5pilotData, as.data.frame(subjectResponses))
postListMat <- round(postListMat, digits=3)
colnames(postListMat) <- colnames(postListMat, do.NULL = FALSE, prefix = "MPost1_")
x5pilotData <- data.frame(x5pilotData, as.data.frame(postListMat))
postListMat2 <- round(postListMat2, digits=3)
colnames(postListMat2) <- colnames(postListMat2, do.NULL = FALSE, prefix = "MPost2_")
x5pilotData <- data.frame(x5pilotData, as.data.frame(postListMat2))
klDivValues <- round(klDivValues, digits=3)
colnames(klDivValues) <- colnames(klDivValues, do.NULL = FALSE, prefix = "KLDiv_")
x5pilotData <- data.frame(x5pilotData, as.data.frame(klDivValues))
#write.csv(x5pilotData, "X5_Data/x5pilotDataAugm_UttChoice_SRSA_fixedAndD.csv")
#write.csv(x5pilotData, "X5_Data/x5pilotDataAugm_UttChoice_SRSA_ADandBD.csv")
#write.csv(x5pilotData, "X5_Data/x5pilotDataAugm_UttChoice_SRSA_ABandABD.csv")
#write.csv(x5pilotData, "X5_Data/x5pilotDataAugm_UttChoice_SRSA.2_fixedAndD.csv")
write.csv(x5pilotData, "X5_Data/x5pilotDataAugm_UttChoice_SRSA.2_ABandBD.csv")
paramsUttWorkers <- as.matrix(read.csv("X5_Data/KLDivUttParamsWorkers_x5_UttChoiceSimpleRSA.2_2019_06_03.csv"))
paramsUttWorkers <- paramsUttWorkers[ , 2:ncol(paramsUttWorkers)]
paramsUttWorkers
source("CommonCode/getConstCodeStratUtt.R")
# loading the augmented pilot data (processed via RSA_x5UttChoiceDataProcessing01.R)
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_fixedAndD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_ADandBD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_ABandABD.csv")
x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_fixedAndD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_ADandBD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_ABandABD.csv")
## adding the 1-27 target and object2 & object3 code.
o1 <- x5UttChoiceData$obj1OC27
o2 <- x5UttChoiceData$obj2OC27
o3 <- x5UttChoiceData$obj3OC27
##
###########
## filtering for only the present feature values for each feature.
###########
subjectGuessIndexM1 <- grep("^DPost_1", colnames(x5UttChoiceData)) - 1
modelGuessIndex1M1 <- grep("^MPost1_1", colnames(x5UttChoiceData)) - 1
modelGuessIndex2M1 <- grep("^MPost2_1", colnames(x5UttChoiceData)) - 1
for(i in c(1:nrow(x5UttChoiceData))) {
currentObjects <- c(o1[i], o2[i], o3[i])
validUtterances <- determineValidUtterances(currentObjects)
for(j in c(1:3)) { # iterating over the three feature types
relevantIndices <- which(validUtterances>(3*(j-1)) & validUtterances<(3*j + 1)) # relevant indices for a particular feature type
valUttRel <- validUtterances[relevantIndices]
# setting the non-represented values to NA
for(v in c(1:3)) {
if(length(which(valUttRel == ((j-1)*3) + v )) == 0) {
x5UttChoiceData[[subjectGuessIndexM1 + ((j-1)*3) + v]][i] <- NA
x5UttChoiceData[[modelGuessIndex1M1 + ((j-1)*3) + v]][i] <- NA
x5UttChoiceData[[modelGuessIndex2M1 + ((j-1)*3) + v]][i] <- NA
}
}
}
}
## now determining the constellation code.
uniqueCCode <- rep(0, length(x5UttChoiceData$X))
featureOrder <- matrix(0, length(x5UttChoiceData$X), 3)
objectOrder <- matrix(0, length(x5UttChoiceData$X), 3)
featureValueOrder <- list()
for(i in c(1:length(x5UttChoiceData$X))) {
objectConstellation <- c(o1[i],o2[i],o3[i])
cc <- getUtteranceChoiceConstellationCode(objectConstellation)
uniqueCCode[i] <- cc[[1]]
featureOrder[i,] <- cc[[2]]
objectOrder[i,] <- cc[[3]]
featureValueOrder[[i]] <- cc[[4]]
}
# feature order specifies reordering of standard order (e.g. shape=1, texture=2, color=3)
# object order specifies reordering of presented object order
# featureValueOrder specifies how the present feature in an object constellation should be ordered.
subjectGuessIndex <- grep("^DPost_1", colnames(x5UttChoiceData))
modelGuessIndex1 <- grep("^MPost1_1", colnames(x5UttChoiceData))
modelGuessIndex2 <- grep("^MPost2_1", colnames(x5UttChoiceData))
x5UttChoiceData$CCode <- uniqueCCode
x5UttChoiceData$featValOrder <- featureValueOrder
#write.csv(x5UttChoiceData, "x5UttChoiceDataModelOptimizedSorted.csv")
################################################################################
x5UttChoiceData <- x5UttChoiceData[order(x5UttChoiceData$CCode),]
myCCodes <- unique(x5UttChoiceData$CCode)
avDataMatrix <- matrix(0,length(myCCodes),19)
dataPointIndex <- 0
workerData <- 0
rsaModel1 <- 0
rsaModel2 <- 0
runIndex <- 1
for(i in c(1:length(myCCodes))) {
cc <- myCCodes[i]
cases <- which(x5UttChoiceData$CCode == cc)
allPilotDataCases <- x5UttChoiceData[cases,]
workerMeans <- 0
rsaModel1Means <- 0
rsaModel2Means <- 0
for(j in c(1:nrow(allPilotDataCases))) {
workerMeans <-  workerMeans + allPilotDataCases[j,subjectGuessIndexM1+(allPilotDataCases$featValOrder[[j]])]
rsaModel1Means <- rsaModel1Means + allPilotDataCases[j,modelGuessIndex1M1+(allPilotDataCases$featValOrder[[j]])]
rsaModel2Means <- rsaModel2Means + allPilotDataCases[j,modelGuessIndex2M1+(allPilotDataCases$featValOrder[[j]])]
}
for(j in c(1:length(workerMeans))) {
workerData[runIndex] <- workerMeans[[j]] / nrow(allPilotDataCases)
rsaModel1[runIndex] <- rsaModel1Means[[j]] / nrow(allPilotDataCases)
rsaModel2[runIndex] <- rsaModel2Means[[j]] / nrow(allPilotDataCases)
runIndex <- runIndex+1
}
}
### plot after Optimization ###
rsaModel1 <- as.array(rsaModel1)
plot(rsaModel1, workerData)
abline(lm(formula = rsaModel1~workerData), col="red") # regression line (y~x)
lines(lowess(rsaModel1,workerData), col="blue") # lowess line (x,y)
model <- lm(formula = rsaModel1~workerData)
summary(model)
confint(model)
### plot with default parameters ###
plot(rsaModel2, workerData)
abline(lm(formula = rsaModel2~workerData), col="red") # regression line (y~x)
lines(lowess(rsaModel2,workerData), col="blue") # lowess line (x,y)
model <- lm(formula = rsaModel2~workerData)
summary(model)
confint(model)
source("CommonCode/getConstCodeStratUtt.R")
# loading the augmented pilot data (processed via RSA_x5UttChoiceDataProcessing01.R)
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_fixedAndD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_ADandBD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_ABandABD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_fixedAndD.csv")
x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_ADandBD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_ABandABD.csv")
## adding the 1-27 target and object2 & object3 code.
o1 <- x5UttChoiceData$obj1OC27
o2 <- x5UttChoiceData$obj2OC27
o3 <- x5UttChoiceData$obj3OC27
##
###########
## filtering for only the present feature values for each feature.
###########
subjectGuessIndexM1 <- grep("^DPost_1", colnames(x5UttChoiceData)) - 1
modelGuessIndex1M1 <- grep("^MPost1_1", colnames(x5UttChoiceData)) - 1
modelGuessIndex2M1 <- grep("^MPost2_1", colnames(x5UttChoiceData)) - 1
for(i in c(1:nrow(x5UttChoiceData))) {
currentObjects <- c(o1[i], o2[i], o3[i])
validUtterances <- determineValidUtterances(currentObjects)
for(j in c(1:3)) { # iterating over the three feature types
relevantIndices <- which(validUtterances>(3*(j-1)) & validUtterances<(3*j + 1)) # relevant indices for a particular feature type
valUttRel <- validUtterances[relevantIndices]
# setting the non-represented values to NA
for(v in c(1:3)) {
if(length(which(valUttRel == ((j-1)*3) + v )) == 0) {
x5UttChoiceData[[subjectGuessIndexM1 + ((j-1)*3) + v]][i] <- NA
x5UttChoiceData[[modelGuessIndex1M1 + ((j-1)*3) + v]][i] <- NA
x5UttChoiceData[[modelGuessIndex2M1 + ((j-1)*3) + v]][i] <- NA
}
}
}
}
## now determining the constellation code.
uniqueCCode <- rep(0, length(x5UttChoiceData$X))
featureOrder <- matrix(0, length(x5UttChoiceData$X), 3)
objectOrder <- matrix(0, length(x5UttChoiceData$X), 3)
featureValueOrder <- list()
for(i in c(1:length(x5UttChoiceData$X))) {
objectConstellation <- c(o1[i],o2[i],o3[i])
cc <- getUtteranceChoiceConstellationCode(objectConstellation)
uniqueCCode[i] <- cc[[1]]
featureOrder[i,] <- cc[[2]]
objectOrder[i,] <- cc[[3]]
featureValueOrder[[i]] <- cc[[4]]
}
# feature order specifies reordering of standard order (e.g. shape=1, texture=2, color=3)
# object order specifies reordering of presented object order
# featureValueOrder specifies how the present feature in an object constellation should be ordered.
subjectGuessIndex <- grep("^DPost_1", colnames(x5UttChoiceData))
modelGuessIndex1 <- grep("^MPost1_1", colnames(x5UttChoiceData))
modelGuessIndex2 <- grep("^MPost2_1", colnames(x5UttChoiceData))
x5UttChoiceData$CCode <- uniqueCCode
x5UttChoiceData$featValOrder <- featureValueOrder
#write.csv(x5UttChoiceData, "x5UttChoiceDataModelOptimizedSorted.csv")
################################################################################
x5UttChoiceData <- x5UttChoiceData[order(x5UttChoiceData$CCode),]
myCCodes <- unique(x5UttChoiceData$CCode)
avDataMatrix <- matrix(0,length(myCCodes),19)
dataPointIndex <- 0
workerData <- 0
rsaModel1 <- 0
rsaModel2 <- 0
runIndex <- 1
for(i in c(1:length(myCCodes))) {
cc <- myCCodes[i]
cases <- which(x5UttChoiceData$CCode == cc)
allPilotDataCases <- x5UttChoiceData[cases,]
workerMeans <- 0
rsaModel1Means <- 0
rsaModel2Means <- 0
for(j in c(1:nrow(allPilotDataCases))) {
workerMeans <-  workerMeans + allPilotDataCases[j,subjectGuessIndexM1+(allPilotDataCases$featValOrder[[j]])]
rsaModel1Means <- rsaModel1Means + allPilotDataCases[j,modelGuessIndex1M1+(allPilotDataCases$featValOrder[[j]])]
rsaModel2Means <- rsaModel2Means + allPilotDataCases[j,modelGuessIndex2M1+(allPilotDataCases$featValOrder[[j]])]
}
for(j in c(1:length(workerMeans))) {
workerData[runIndex] <- workerMeans[[j]] / nrow(allPilotDataCases)
rsaModel1[runIndex] <- rsaModel1Means[[j]] / nrow(allPilotDataCases)
rsaModel2[runIndex] <- rsaModel2Means[[j]] / nrow(allPilotDataCases)
runIndex <- runIndex+1
}
}
### plot after Optimization ###
rsaModel1 <- as.array(rsaModel1)
plot(rsaModel1, workerData)
abline(lm(formula = rsaModel1~workerData), col="red") # regression line (y~x)
lines(lowess(rsaModel1,workerData), col="blue") # lowess line (x,y)
model <- lm(formula = rsaModel1~workerData)
summary(model)
confint(model)
### plot with default parameters ###
plot(rsaModel2, workerData)
abline(lm(formula = rsaModel2~workerData), col="red") # regression line (y~x)
lines(lowess(rsaModel2,workerData), col="blue") # lowess line (x,y)
model <- lm(formula = rsaModel2~workerData)
summary(model)
confint(model)
source("CommonCode/getConstCodeStratUtt.R")
# loading the augmented pilot data (processed via RSA_x5UttChoiceDataProcessing01.R)
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_fixedAndD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_ADandBD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_RSA_UttChoice_ABandABD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_fixedAndD.csv")
#x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_ADandBD.csv")
x5UttChoiceData <- read.csv("X5_Data/x5pilotDataAugm_UttChoice_SRSA_ABandABD.csv")
## adding the 1-27 target and object2 & object3 code.
o1 <- x5UttChoiceData$obj1OC27
o2 <- x5UttChoiceData$obj2OC27
o3 <- x5UttChoiceData$obj3OC27
##
###########
## filtering for only the present feature values for each feature.
###########
subjectGuessIndexM1 <- grep("^DPost_1", colnames(x5UttChoiceData)) - 1
modelGuessIndex1M1 <- grep("^MPost1_1", colnames(x5UttChoiceData)) - 1
modelGuessIndex2M1 <- grep("^MPost2_1", colnames(x5UttChoiceData)) - 1
for(i in c(1:nrow(x5UttChoiceData))) {
currentObjects <- c(o1[i], o2[i], o3[i])
validUtterances <- determineValidUtterances(currentObjects)
for(j in c(1:3)) { # iterating over the three feature types
relevantIndices <- which(validUtterances>(3*(j-1)) & validUtterances<(3*j + 1)) # relevant indices for a particular feature type
valUttRel <- validUtterances[relevantIndices]
# setting the non-represented values to NA
for(v in c(1:3)) {
if(length(which(valUttRel == ((j-1)*3) + v )) == 0) {
x5UttChoiceData[[subjectGuessIndexM1 + ((j-1)*3) + v]][i] <- NA
x5UttChoiceData[[modelGuessIndex1M1 + ((j-1)*3) + v]][i] <- NA
x5UttChoiceData[[modelGuessIndex2M1 + ((j-1)*3) + v]][i] <- NA
}
}
}
}
## now determining the constellation code.
uniqueCCode <- rep(0, length(x5UttChoiceData$X))
featureOrder <- matrix(0, length(x5UttChoiceData$X), 3)
objectOrder <- matrix(0, length(x5UttChoiceData$X), 3)
featureValueOrder <- list()
for(i in c(1:length(x5UttChoiceData$X))) {
objectConstellation <- c(o1[i],o2[i],o3[i])
cc <- getUtteranceChoiceConstellationCode(objectConstellation)
uniqueCCode[i] <- cc[[1]]
featureOrder[i,] <- cc[[2]]
objectOrder[i,] <- cc[[3]]
featureValueOrder[[i]] <- cc[[4]]
}
# feature order specifies reordering of standard order (e.g. shape=1, texture=2, color=3)
# object order specifies reordering of presented object order
# featureValueOrder specifies how the present feature in an object constellation should be ordered.
subjectGuessIndex <- grep("^DPost_1", colnames(x5UttChoiceData))
modelGuessIndex1 <- grep("^MPost1_1", colnames(x5UttChoiceData))
modelGuessIndex2 <- grep("^MPost2_1", colnames(x5UttChoiceData))
x5UttChoiceData$CCode <- uniqueCCode
x5UttChoiceData$featValOrder <- featureValueOrder
#write.csv(x5UttChoiceData, "x5UttChoiceDataModelOptimizedSorted.csv")
################################################################################
x5UttChoiceData <- x5UttChoiceData[order(x5UttChoiceData$CCode),]
myCCodes <- unique(x5UttChoiceData$CCode)
avDataMatrix <- matrix(0,length(myCCodes),19)
dataPointIndex <- 0
workerData <- 0
rsaModel1 <- 0
rsaModel2 <- 0
runIndex <- 1
for(i in c(1:length(myCCodes))) {
cc <- myCCodes[i]
cases <- which(x5UttChoiceData$CCode == cc)
allPilotDataCases <- x5UttChoiceData[cases,]
workerMeans <- 0
rsaModel1Means <- 0
rsaModel2Means <- 0
for(j in c(1:nrow(allPilotDataCases))) {
workerMeans <-  workerMeans + allPilotDataCases[j,subjectGuessIndexM1+(allPilotDataCases$featValOrder[[j]])]
rsaModel1Means <- rsaModel1Means + allPilotDataCases[j,modelGuessIndex1M1+(allPilotDataCases$featValOrder[[j]])]
rsaModel2Means <- rsaModel2Means + allPilotDataCases[j,modelGuessIndex2M1+(allPilotDataCases$featValOrder[[j]])]
}
for(j in c(1:length(workerMeans))) {
workerData[runIndex] <- workerMeans[[j]] / nrow(allPilotDataCases)
rsaModel1[runIndex] <- rsaModel1Means[[j]] / nrow(allPilotDataCases)
rsaModel2[runIndex] <- rsaModel2Means[[j]] / nrow(allPilotDataCases)
runIndex <- runIndex+1
}
}
### plot after Optimization ###
rsaModel1 <- as.array(rsaModel1)
plot(rsaModel1, workerData)
abline(lm(formula = rsaModel1~workerData), col="red") # regression line (y~x)
lines(lowess(rsaModel1,workerData), col="blue") # lowess line (x,y)
model <- lm(formula = rsaModel1~workerData)
summary(model)
confint(model)
### plot with default parameters ###
plot(rsaModel2, workerData)
abline(lm(formula = rsaModel2~workerData), col="red") # regression line (y~x)
lines(lowess(rsaModel2,workerData), col="blue") # lowess line (x,y)
model <- lm(formula = rsaModel2~workerData)
summary(model)
confint(model)
